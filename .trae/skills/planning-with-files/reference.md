# 参考：Manus上下文工程原则

此技能基于Manus的上下文工程原则，Manus是一家AI代理公司，于2025年12月被Meta以20亿美元收购。

## 6个Manus原则

### 原则1：围绕KV-Cache设计

> "KV-cache命中率是生产AI代理最重要的单一指标。"

**统计数据：**
- ~100:1 输入到输出token比率
- 缓存token：$0.30/MTok vs 未缓存：$3/MTok
- 10倍成本差异！

**实现：**
- 保持提示前缀稳定（单token更改使缓存失效）
- 系统提示中不要时间戳
- 使上下文仅追加，具有确定性序列化

### 原则2：掩码，不要移除

不要动态移除工具（破坏KV-cache）。改用logit掩码。

**最佳实践：** 使用一致的操作前缀（例如，`browser_`、`shell_`、`file_`）以便于掩码。

### 原则3：文件系统作为外部内存

> "Markdown是我在磁盘上的'工作记忆'。"

**公式：**
```
上下文窗口 = 内存（易失性，有限）
文件系统 = 磁盘（持久性，无限）
```

**压缩必须可恢复：**
- 即使web内容被丢弃，也要保留URL
- 丢弃文档内容时保留文件路径
- 绝不丢失完整数据的指针

### 原则4：通过复述操纵注意力

> "在整个任务中创建和更新todo.md，将全局计划推入模型的近期注意力范围。"

**问题：** 约50次工具调用后，模型忘记原始目标（"中间丢失"效应）。

**解决方案：** 在每个决策前重新阅读`task_plan.md`。目标出现在注意力窗口中。

```
上下文开始：[原始目标 - 遥远，被遗忘]
...许多工具调用...
上下文结束：[最近阅读的task_plan.md - 获得注意力！]
```

### 原则5：保留错误的东西

> "将错误的转向留在上下文中。"

**为什么：**
- 带有堆栈跟踪的失败操作让模型隐式更新信念
- 减少错误重复
- 错误恢复是"真正代理行为的最清晰信号之一"

### 原则6：不要被少样本化

> "一致性滋生脆弱性。"

**问题：** 重复的动作-观察对导致漂移和幻觉。

**解决方案：** 引入受控变化：
- 稍微改变措辞
- 不要盲目复制粘贴模式
- 在重复任务上重新校准

---

## 3个上下文工程策略

基于Lance Martin对Manus架构的分析。

### 策略1：上下文缩减

**压缩：**
```
工具调用有两种表示：
├── 完整：原始工具内容（存储在文件系统中）
└── 紧凑：仅引用/文件路径

规则：
- 对陈旧（较旧）的工具结果应用压缩
- 保持最近结果完整（以指导下一个决策）
```

**摘要化：**
- 当压缩达到收益递减时应用
- 使用完整工具结果生成
- 创建标准化摘要对象

### 策略2：上下文隔离（多代理）

**架构：**
```
┌─────────────────────────────────┐
│         规划代理                │
│  └─ 将任务分配给子代理         │
├─────────────────────────────────┤
│       知识管理器                │
│  └─ 审查对话                   │
│  └─ 确定文件系统存储           │
├─────────────────────────────────┤
│      执行子代理                │
│  └─ 执行分配的任务             │
│  └─ 有自己的上下文窗口         │
└─────────────────────────────────┘
```

**关键洞察：** Manus最初使用`todo.md`进行任务规划，但发现约33%的操作用于更新它。转向专用规划代理调用执行子代理。

### 策略3：上下文卸载

**工具设计：**
- 总共使用<20个原子函数
- 将完整结果存储在文件系统中，而不是上下文中
- 使用`glob`和`grep`进行搜索
- 渐进式披露：仅在需要时加载信息

---

## 代理循环

Manus在连续的7步循环中运行：

```
┌─────────────────────────────────────────┐
│  1. 分析上下文                          │
│     - 理解用户意图                     │
│     - 评估当前状态                     │
│     - 审查最近观察                     │
├─────────────────────────────────────────┤
│  2. 思考                                │
│     - 我应该更新计划吗？               │
│     - 下一个逻辑动作是什么？           │
│     - 有阻塞吗？                       │
├─────────────────────────────────────────┤
│  3. 选择工具                            │
│     - 选择一个工具                     │
│     - 确保参数可用                     │
├─────────────────────────────────────────┤
│  4. 执行动作                            │
│     - 工具在沙箱中运行                 │
├─────────────────────────────────────────┤
│  5. 接收观察                            │
│     - 结果附加到上下文                 │
├─────────────────────────────────────────┤
│  6. 迭代                                │
│     - 返回步骤1                        │
│     - 继续直到完成                     │
├─────────────────────────────────────────┤
│  7. 交付结果                            │
│     - 将结果发送给用户                 │
│     - 附加所有相关文件                 │
└─────────────────────────────────────────┘
```

---

## Manus创建的文件类型

| 文件 | 用途 | 何时创建 | 何时更新 |
|------|---------|--------------|--------------|
| `task_plan.md` | 阶段跟踪，进度 | 任务开始 | 完成阶段后 |
| `findings.md` | 发现，决策 | 任何发现后 | 查看图像/PDF后 |
| `progress.md` | 会话日志，做了什么 | 断点处 | 整个会话期间 |
| 代码文件 | 实现 | 执行前 | 错误后 |

---

## 关键约束

- **单动作执行：** 每轮一个工具调用。无并行执行。
- **计划是必需的：** 代理必须始终知道：目标、当前阶段、剩余阶段
- **文件是内存：** 上下文 = 易失性。文件系统 = 持久性。
- **绝不重复失败：** 如果动作失败，下一个动作必须不同
- **通信是工具：** 消息类型：`info`（进度）、`ask`（阻塞）、`result`（终端）

---

## Manus统计数据

| 指标 | 值 |
|--------|-------|
| 每个任务的平均工具调用 | ~50 |
| 输入到输出token比率 | 100:1 |
| 收购价格 | 20亿美元 |
| 达到1亿美元收入的时间 | 8个月 |
| 自发布以来的框架重构 | 5次 |

---